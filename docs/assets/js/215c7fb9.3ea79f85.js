"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[2700],{7868:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var i=t(7624),o=t(2172);const a={sidebar_position:1},s="What is x-view-model?",r={id:"introduction/summary",title:"What is x-view-model?",description:"Binding view and view-model",source:"@site/docs/introduction/summary.mdx",sourceDirName:"introduction",slug:"/introduction/summary",permalink:"/x-view-model/docs/introduction/summary",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/x-view-model/docs/category/introduction"},next:{title:"Comparison With hooks",permalink:"/x-view-model/docs/introduction/quick_guide"}},d={},l=[];function c(e){const n={blockquote:"blockquote",code:"code",h1:"h1",li:"li",p:"p",ul:"ul",...(0,o.M)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"what-is-x-view-model",children:"What is x-view-model?"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Binding view and view-model"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"x-view-model"})," is a solution that make react hooks support MVVM without introduce any third-party libriries and aims to separates UI from business logic and provide immutable data & global state management, memory management and persistent data management and provide intuitive API."]}),"\n",(0,i.jsxs)(n.p,{children:["Using ",(0,i.jsx)(n.code,{children:"x-view-model"})," will bring a lot of convenience as follows:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\ud83d\udcbc Provide global and local state management, without introducing reducer or redux and other state management solutions;"}),"\n",(0,i.jsx)(n.li,{children:"\ud83c\udf32 Provide global cache and persistent data storage management;"}),"\n",(0,i.jsx)(n.li,{children:"\ud83c\udfa9 It can make the business code more organized, maintainable and testable, and the division of responsibilities is clearer."}),"\n",(0,i.jsx)(n.li,{children:"\ud83c\udf70 Effectively avoid the problem of too many states that need to be managed inside the component, and simplify the useState and setState writing methods in the form of objects."}),"\n",(0,i.jsx)(n.li,{children:"\ud83c\udf77 There is no need to care about hooks inside the class-based ViewModel, so you can focus more on business logic development."}),"\n",(0,i.jsxs)(n.li,{children:["\ud83d\udc4b It can realize global data update and cross-component data transfer without ",(0,i.jsx)(n.code,{children:"useReducer"})," or context"]}),"\n",(0,i.jsx)(n.li,{children:"\ud83c\udf32 Different stores are divided according to the key, the view component will not respond to the state changes of the unused stores, and the performance overhead can be canceled"}),"\n",(0,i.jsx)(n.li,{children:"\ud83c\udf73 ViewModel will provide basic lifecycle functions, which is more convenient than useEffect to handle asynchronous functions"}),"\n",(0,i.jsx)(n.li,{children:"\ud83c\udf56 ViewModel will automatically trigger memory recycling according to the life cycle of react hooks, and memory management is more efficient"}),"\n",(0,i.jsxs)(n.li,{children:["\ud83e\udd52 No need to use ",(0,i.jsx)(n.code,{children:"useCallback"})," to deal with component re-rendering problems caused by avoiding function reference changes."]}),"\n",(0,i.jsx)(n.li,{children:"\ud83c\udf70 After calling the updater to update, the latest state value can be obtained synchronously"}),"\n",(0,i.jsx)(n.li,{children:"\ud83d\udc4b It can realize fine-grained update of the attribute value of the object, and can realize immutable data"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.M)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);